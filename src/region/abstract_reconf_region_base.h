/**
 * Copyright 2024 The NC-Library Authors. All rights reserved.
 *
 * Licensed under Apache License Version 2.0.
 *
 */
#ifndef REGION_ABSTRACT_RECONF_REGION_BASE_H_
#define REGION_ABSTRACT_RECONF_REGION_BASE_H_

#include <systemc.h>

class reconf_lock;
class conf_manager_base;
class abstract_module_base;

/**
 * Abstract base for every specialized reconfiguration region base generated
 * from an interface description. It contains logic for module management which
 * can be performed without knowledge of the concrete reconfiguration region
 * interface. The reconfiguration region interface class, generated by the macro
 * NC_REGISTER_INTERFACE, will extend this class with the necessary members.
 */
class abstract_reconf_region_base : public ::sc_core::sc_module {
  friend class reconf_lock;           // for counting transactions
  friend class conf_manager_base;     // for marking (nested) reconfiguration
  friend class abstract_module_base;  // for calling do_preload

  /**
   * Mark that an transaction was started by the configured module, but only if
   * transactions are currently not blocked.
   */
  inline void start_transaction() {
    if (m_transactions_blocked) {
      SC_REPORT_ERROR(name(),
                      "Tried to start an interaction with a module while "
                      "reconfiguration is in progress.");
    }
    ++m_active_trans_count;
  }

  /**
   * Mark that one of the transactions ended, that was previously started by the
   * configured module.
   */
  inline void end_transaction() {
    sc_assert(
        m_active_trans_count > 0 &&
        "Signaled end of transaction when there is no transaction on progress");
    --m_active_trans_count;
  }

 protected:
  /**
   * Mark that the reconfiguration process has been started.
   */
  inline void mark_reconf_begin() {
    if (m_reconfiguring) {
      SC_REPORT_ERROR(name(), "Reconfiguration already in progress.");
    }
    m_reconfiguring = true;
  }

  /**
   * Mark that the reconfiguration process has ended.
   */
  inline void mark_reconf_end() {
    sc_assert(m_reconfiguring && "No reconfiguration in progress.");
    m_reconfiguring = false;
  }

  /**
   * Block any further transactions from starting.
   */
  inline void block_transactions() {
    sc_assert(!m_transactions_blocked && "Transactions are already blocked.");
    m_transactions_blocked = true;
  }

  /**
   * Allow new transactions to start again.
   */
  inline void unblock_transactions() {
    sc_assert(m_transactions_blocked && "Transactions are not blocked.");
    m_transactions_blocked = false;
  }

  /**
   * Check whether the configured module can be unload right now, a.k.a. whether
   * there are no transactions in process.
   */
  inline void is_unload_ok() const {
    if (m_active_trans_count != 0) {
      SC_REPORT_ERROR(
          name(),
          "Cannot reconfigure a module while there are still active "
          "interaction with it.");
    }
  }

  /**
   * Check whether transactions are blocked at the moment.
   * @return true if transactions are blocked currently, false otherwise
   */
  inline bool transactions_blocked() const { return m_transactions_blocked; }

  /**
   * Check whether the reconfiguration region is nested in a module or at
   * top-level.
   * @return true when it is nested, false otherwise
   */
  bool is_nested_rr() const { return m_base_module != nullptr; }

  /**
   * Actually load the module that was registered for preload.
   */
  virtual void do_preload() = 0;

 public:
  /**
   * Constructor for an abstract reconfiguration region.
   * The given name will be passed to the sc_module constructor.
   * If the module pointer is not a nullptr, the reconfiguration region will be
   * registered as nested reconfiguration region at this module.
   *
   * @param name the name of the module
   * @param base_module the module in which the reconfiguration region is nested
   * or nullptr if it is in the static design
   */
  abstract_reconf_region_base(const sc_core::sc_module_name& name,
                              abstract_module_base* base_module);

  /**
   * Unload the currently configured module.
   */
  virtual void unload_module() = 0;

  /**
   * Check whether there is an reconfiguration process ongoing.
   * @return
   */
  inline bool is_reconfiguring() const { return m_reconfiguring; }

 protected:
  /// @brief Pointer to the module that the reconfiguration region is contained
  /// in (nullptr => RR on top-level).
  abstract_module_base* m_base_module;

 private:
  /// @brief Flag indicating whether there is a reconfiguration in progress.
  bool m_reconfiguring = false;
  /// @brief Flag indicating whether transactions are blocked.
  bool m_transactions_blocked = false;
  /// @brief Number of transactions that have been started by the module but did
  /// not end yet (a.k.a. are active).
  size_t m_active_trans_count = 0;
};

#endif  // REGION_ABSTRACT_RECONF_REGION_BASE_H_
